import OpenAI from "openai";
import sql from "../configs/db.js";
import { clerkClient } from "@clerk/express";
import {v2 as cloudinary} from "cloudinary"
import axios from "axios";
import FormData from "form-data";
import fs from "fs"
import pdf from "pdf-parse/lib/pdf-parse.js"

const AI = new OpenAI({
    apiKey: process.env.GEMINI_API_KEY,
    baseURL: "https://generativelanguage.googleapis.com/v1beta/openai/"
});

export const generateArticle = async (req,res)=>{ 
    try {
        const { userId } = req.auth;
        const {prompt , length} = req.body;
        const plan = req.plan;
        const free_usage = req.free_usage;

        if(plan !== 'premium' && free_usage >= 10){
            return res.json({success:false , message : "Limit reached , upgrade to continue."})
        }
        // refer to google ai studio to get gemini api key and then go to documentation and get started with openai compatibility

        const response = await AI.chat.completions.create({
            model: "gemini-2.0-flash",
            messages: [
                {
                    role: "user",
                    content: prompt,
                },
            ],
            temperature:0.7, // temperature shows that the answer generated by AI is how much accurate , diverse , creative.
            max_tokens:length
        });

        const content = response.choices[0].message.content;

        await sql` INSERT INTO creations(user_id , prompt , content , type)
        VALUES (${userId} , ${prompt} ,${content} ,'article')`;


        if(plan !== 'premium'){
            await clerkClient.users.updateUserMetadata(userId , {
            privateMetadata:{
                free_usage : free_usage + 1
            }
        })
    }

        res.json({success:true , content})

    } catch (error) {
        res.json({success:false , message:error.message})
    }
}

export const generateBlogTitle = async (req,res)=>{ 
    try {
        const { userId } = req.auth;
        const {prompt} = req.body;
        console.log(prompt)
        const plan = req.plan;
        const free_usage = req.free_usage;

        if(plan !== 'premium' && free_usage >= 10){
            return res.json({success:false , message : "Limit reached , upgrade to continue."})
        }
        // refer to google ai studio to get gemini api key and then go to documentation and get started with openai compatibility

        const response = await AI.chat.completions.create({
            model: "gemini-2.0-flash",
            messages: [
                {
                    role: "user",
                    content: prompt,
                },
            ],
            temperature:0.7, // temperature shows that the answer generated by AI is how much accurate , diverse , creative.
            max_tokens:100
        });

        const content = response.choices[0].message.content;

        await sql` INSERT INTO creations(user_id , prompt , content , type)
        VALUES (${userId} , ${prompt} ,${content} ,'blog-title')`;


        if(plan !== 'premium'){
            await clerkClient.users.updateUserMetadata(userId , {
            privateMetadata:{
                free_usage : free_usage + 1
            }
        })
    }
    
    res.json({success:true , content})

    } catch (error) {
        res.json({success:false , message:error.message})
    }
}

export const generateImage = async (req,res)=>{ 
    try {
        const { userId } = req.auth;
        const {prompt , publish} = req.body;
        const plan = req.plan;

        if(plan !== 'premium'){
            return res.json({success:false , message : "This feature is only available for premium subscriptions"})
        }
        

        const formData = new FormData()
        formData.append('prompt', prompt);
        
        const {data} = await axios.post("https://clipdrop-api.co/text-to-image/v1" ,
            formData , {
                headers : {'x-api-key': process.env.CLIPDROP_API_KEY,},
                responseType: "arraybuffer", // clipdrop api sends an arraybuffer(data) , its basically a raw binary image data
            }
        )
        // convert arrayBuffer to buffer
        const buffer = Buffer.from(data , 'binary'); // buffer is node.js native binary type
        // convert buffer to base64
        const base64Image = buffer.toString("base64");
        // Add MIME type prefix for frontend
        const imageData = `data:image/png;base64,${base64Image}`

        const {secure_url} = await cloudinary.uploader.upload(imageData)

        await sql` INSERT INTO creations(user_id , prompt , content , type , publish)
        VALUES (${userId} , ${prompt} ,${secure_url} ,'image' , ${publish ?? false})`; // publish ?? false -> it means if publish is undefiend or null then use false otherwise use actual value of publish.

        res.json({success:true , content:secure_url})
    }

    catch (error) {
        res.json({success:false , message:error.message})
    }
}

export const removeImageBackground = async (req,res)=>{ 
    try {
        const { userId } = req.auth;
        const image = req.file;
        // console.log(image); image is a object 
        const plan = req.plan;

        if(plan !== 'premium'){
            return res.json({success:false , message : "This feature is only available for premium subscriptions"})
        }
        

        const {secure_url} = await cloudinary.uploader.upload(image.path,{
            transformation:[
                {
                    effect:'background_removal',
                    background_removal:'remove_the_background'
                }
            ]
        })

        await sql` INSERT INTO creations(user_id , prompt , content , type )
        VALUES (${userId} , 'Remove Background from Image' ,${secure_url} ,'remove-background')`; 

        res.json({success:true , content:secure_url})
    }

    catch (error) {
        res.json({success:false , message:error.message})
    }
}

export const removeImageObject = async (req,res)=>{ 
    try {
        const { userId } = req.auth;
        const {object} = req.body;
        const image = req.file;
        const plan = req.plan;

        if(plan !== 'premium'){
            return res.json({success:false , message : "This feature is only available for premium subscriptions"})
        }
        

        const {public_id} = await cloudinary.uploader.upload(image.path)

        const imageUrl =  cloudinary.url(public_id,{
            transformation:[
                {
                    effect:`gen_remove:${object}`
                }
            ],
            resource_type:"image"
        })

        await sql` INSERT INTO creations(user_id , prompt , content , type )
        VALUES (${userId} , ${`Removed ${object} from image`} ,${imageUrl} ,'remove-object')`; 

        res.json({success:true , content:imageUrl})
    }

    catch (error) {
        res.json({success:false , message:error.message})
    }
}

export const reviewResume = async (req,res)=>{ 
    console.log("REQ.FILE:", req.file);
    try {
        const {userId} = req.auth;
        const resume = req.file;
        const plan = req.plan;

        if(plan !== 'premium'){
            return res.json({success:false , message : "This feature is only available for premium subscriptions"})
        }
        
        if(resume.size > 5 * 1024 * 1024){
            res.json({success:false , message : "Resume file size exceeds allowed size (5MB). "})
        }

        // we use diskStorage with multer , so to read resume file from disk we use fileSystem (fs.readFileSync(file path))

        const dataBuffer = fs.readFileSync(resume.path) // read the pdf file from disk into buffer

        // we use pdf-parser to extract text from buffer

        const pdfData = await pdf(dataBuffer)

        const prompt = `Review the following resume and provide constructive feedback
        on its strength , weaknesses , and areas for improvement. Resume Content:\n\n${pdfData.text}`

         const response = await AI.chat.completions.create({
            model: "gemini-2.0-flash",
            messages: [
                {
                    role: "user",
                    content: prompt,
                },
            ],
            temperature:0.7, // temperature shows that the answer generated by AI is how much accurate , diverse , creative.
            max_tokens:1000,
        });

        const content = response.choices[0].message.content;

        await sql` INSERT INTO creations(user_id , prompt , content , type )
        VALUES (${userId} , 'Review the uploaded Resume' ,${content} ,'resume-review')`; 

        res.json({success:true , content})
    }

    catch (error) {
        res.json({success:false , message:error.message})
    }
}